

轻量级非侵入式的依赖注入与配置管理组件库

正如高楼大厦都是由一块块砖头砌成的，brick砖头在这里就是一个组件

空tag默认使用typeID作为liveID, 约定俗成大家都方便，配置文件必须写liveID，推荐单例的liveID设置为typeID。因为大部分情况都是单例，大家想偷懒。

brick实例的liveID 目前不允许与其他类型brick的typeID相同，否则brick库会抛出panic。因为每一个brick类型的默认liveID就是typeID，当调用者想要获取brick的默认实例时可能会出现意料之外的问题，所以这个约束是合理的。


**Brick: A Lightweight, Non-Intrusive Component-Based Configuration and Dependency Injection Library**



BrickTypeID方法返回一个静态字符串ID，所有拥有BrickTypeID方法的类型都视为brick组件，brick组件可以选择实现BrickNewer接口来提供配置解析功能。
typeID唯一的标识了一个brick组件类型，brick组件可以存在多个实例，每一个通过brick库实例化的组件都拥有一个liveID，liveID是brick组件的唯一标识。

建议使用随机字符串作为typeID与liveID以避免组件之间的冲突，当brick组件为单例时，我们强烈建议将liveID设置为typeID，这样可以使依赖注入更加简洁方便。
空tag默认使用typeID作为注入实例的liveID。

有一个强制约束，在配置文件中，同一类型的brick组件所有实例的liveID中必须有一个设置为typeID，否则brick库会抛出panic，如果想关闭这个约束，可以调用SetLiveIDConstraint(false)方法。

组件之间的循环依赖是不允许的，如果组件A依赖组件B，组件B依赖组件A，则brick库会抛出panic。

每一个brick组件都可以依赖其他brick组件，只需要在tag中指定依赖的brick组件的liveID，brick库会自动将依赖的brick组件注入到当前组件中。



组件配置文件示例:

```json
{
    "bricks": [
        {
            "metaData": {
                "name": "Logger Brick",
                "typeID": "Logger-XU8WQNK1F65QVH4OQ5XY"
            },
            "lives": [
                {
                    "liveID": "Logger-XU8WQNK1F65QVH4OQ5XY",
                    "config": {
                        "prefix": "Prefix1",
                        "logLevel": "DEBUG"
                    }
                },
                {
                    "liveID": "Logger-QAAHX1JWAVS4T1KKAN6B",
                    "config": {
                        "prefix": "Prefix2",
                        "logLevel": "DEBUG"
                    }
                }
            ]
        }
    ]
}
```

metaData中的name字段是组件的名称，typeID是组件的唯一标识，
lives里包含此类型brick组件的实例配置，liveID是实例的唯一标识，config是实例的配置。

依赖注入示例:

```go
type Logger struct {
    Prefix string `json:"prefix"`
    LogLevel string `json:"logLevel"`
}

func (l *Logger) BrickTypeID() string {
    return "Logger-XU8WQNK1F65QVH4OQ5XY"
}

func (l *Logger) NewBrick(jsonConf []byte) brick.Brick {
    var newLogger = &Logger{}
    err := json.Unmarshal(jsonConf, newLogger)
    if err != nil {
        panic(fmt.Errorf("failed to unmarshal logger config: %w", err))
    }
    return newLogger
}

type Service struct {
    Logger *Logger `brick:""` // 空tag等价于使用此类型的typeID作为注入实例的liveID
    Logger2 *Logger `brick:"Logger-QAAHX1JWAVS4T1KKAN6B"` // brick tag中的内容为需要注入实例的liveID
}

func (s *Service) BrickTypeID() string {
    return "Service-961S959CDPWBCD8462A8"
}
``` 




```go
type Logger struct {
	Prefix      string `json:"prefix"`
	LogLevel    string `json:"logLevel"`
	EnableColor bool   `json:"enableColor"`
}

func (l *Logger) BrickTypeID() string {
	return "Logger-XU8WQNK1F65QVH4OQ5XY"
}

func (l *Logger) NewBrick(jsonConf []byte) brick.Brick {
	var newLogger = &Logger{}
	err := json.Unmarshal(jsonConf, newLogger)
	if err != nil {
		panic(fmt.Errorf("failed to unmarshal logger config: %w", err))
	}
	return newLogger
}

func (l *Logger) BrickTypeLives() []string {
	return []string{"Logger-XU8WQNK1F65QVH4OQ5XY", "Logger-QAAHX1JWAVS4T1KKAN6B"}
}
```